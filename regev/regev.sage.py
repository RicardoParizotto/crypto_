

# This file was *autogenerated* from the file regev.sage
from sage.all_cmdline import *   # import sage library

_sage_const_9 = Integer(9); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_1p0 = RealNumber('1.0'); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)#!/usr/bin/env sage
from sage.misc.prandom import randrange
import sage.stats.distributions.discrete_gaussian_integer as dgi

# 1) Parameters
q, n, m = _sage_const_9 , _sage_const_4 , _sage_const_4 
R = Integers(q)
Q = Rationals()
Z2 = Integers(_sage_const_2 )

# 2) Helper function for noise
def sample_noise(N):
    D = dgi.DiscreteGaussianDistributionIntegerSampler(sigma=_sage_const_1p0 )
    return vector([R(D()) for _ in range(N)])

# 3) Key Generation
# Secret key s (vector of length n)
s_vec = vector([R.random_element() for _ in range(n)])
print("secret s (vector):", s_vec)

# Public matrix A (n x m)
A = matrix(R, n, m, [R.random_element() for _ in range(n*m)])
print("A:\n", A)

# Noise e (vector of length m)
e_vec = sample_noise(m)
print("noise e (vector):", e_vec)

# To compute s.T * A, we treat s and e as matrices
# Converts the vector s to a 1-row matrix
# Converts the vector e to a 1-row matrix
s_mat = matrix(s_vec) 
e_mat = matrix(e_vec) 

# Public vector b (length m), computed via transpose
# b.T = s.T * A + e.T
bT = s_mat * A + e_mat       # No transpose needed on s_mat, as it's already a row
b = vector(R, bT[_sage_const_0 ])  # Convert back to a vector
print("b.T = s*A + e:", bT)
print("b:", b)

# 4) Encryption of a single bit
msg = R(randrange(_sage_const_2 ))
print("\nmessage:", msg)

# Random vector r (length m)
r = vector(R, [randrange(_sage_const_2 ) for _ in range(m)])
print("r:", r)

# Ciphertext component u
# u = A*r (vector of length n)
u = A * r
print("u = A*r:", u)

# Ciphertext component v
# v = b.T*r + msg*(q//2) which is the dot product
v = b.dot_product(r) + msg*(q//_sage_const_2 )
print("v = b.T*r + msg*floor(q/2):", v)

# 5) Decryption
# Compute v' = v - s'*u which is v - s.dot_product(u)
dv = v - s_vec.dot_product(u) # Use the original s_vec for the dot product
print("\ndecryption value dv =", dv)

# Turn dv (element of R) into a standard integer
dv_int = Integer(dv)

# Decide based on distance to 0 vs. q/2
if dv_int <= q//_sage_const_4  or dv_int >= q - q//_sage_const_4 :
    dec = _sage_const_0 
else:
    dec = _sage_const_1 

print("decrypted:", dec)
print("correct?", dec == Integer(msg))

